"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[1984],{28453:(i,n,e)=>{e.d(n,{R:()=>t,x:()=>a});var s=e(96540);const r={},l=s.createContext(r);function t(i){const n=s.useContext(l);return s.useMemo(function(){return"function"==typeof i?i(n):{...n,...i}},[n,i])}function a(i){let n;return n=i.disableParentContext?"function"==typeof i.components?i.components(r):i.components||r:t(i.components),s.createElement(l.Provider,{value:n},i.children)}},69451:(i,n,e)=>{e.r(n),e.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"chapters/module-2-digital-twin/basics","title":"Chapter 1: Digital Twin Basics","description":"Digital twin concepts, simulation fidelity, and sim-to-real gap","source":"@site/docs/chapters/module-2-digital-twin/01-basics.md","sourceDirName":"chapters/module-2-digital-twin","slug":"/chapters/module-2-digital-twin/basics","permalink":"/Physical-AI-Humanoid-Robotics/chapters/module-2-digital-twin/basics","draft":false,"unlisted":false,"editUrl":"https://github.com/ayeshadev283-max/Physical-AI-Humanoid-Robotics/tree/main/docs/chapters/module-2-digital-twin/01-basics.md","tags":[{"inline":true,"label":"digital-twin","permalink":"/Physical-AI-Humanoid-Robotics/tags/digital-twin"},{"inline":true,"label":"simulation","permalink":"/Physical-AI-Humanoid-Robotics/tags/simulation"},{"inline":true,"label":"fidelity","permalink":"/Physical-AI-Humanoid-Robotics/tags/fidelity"},{"inline":true,"label":"sim-to-real","permalink":"/Physical-AI-Humanoid-Robotics/tags/sim-to-real"},{"inline":true,"label":"domain-randomization","permalink":"/Physical-AI-Humanoid-Robotics/tags/domain-randomization"}],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Chapter 1: Digital Twin Basics","description":"Digital twin concepts, simulation fidelity, and sim-to-real gap","tags":["digital-twin","simulation","fidelity","sim-to-real","domain-randomization"]},"sidebar":"bookSidebar","previous":{"title":"Module 2: Digital Twin","permalink":"/Physical-AI-Humanoid-Robotics/module-2-digital-twin"},"next":{"title":"Chapter 2: Gazebo Physics","permalink":"/Physical-AI-Humanoid-Robotics/chapters/module-2-digital-twin/gazebo-physics"}}');var r=e(74848),l=e(28453);const t={sidebar_position:1,title:"Chapter 1: Digital Twin Basics",description:"Digital twin concepts, simulation fidelity, and sim-to-real gap",tags:["digital-twin","simulation","fidelity","sim-to-real","domain-randomization"]},a="Chapter 1: Digital Twin Basics",o={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"1.1 Digital Twin Concept",id:"11-digital-twin-concept",level:2},{value:"Definition",id:"definition",level:3},{value:"Historical Context",id:"historical-context",level:3},{value:"Use Cases in Robotics",id:"use-cases-in-robotics",level:3},{value:"Digital Twin vs Simulation",id:"digital-twin-vs-simulation",level:3},{value:"1.2 Simulation Fidelity Tradeoffs",id:"12-simulation-fidelity-tradeoffs",level:2},{value:"Dimensions of Fidelity",id:"dimensions-of-fidelity",level:3},{value:"Speed vs Accuracy",id:"speed-vs-accuracy",level:3},{value:"Fidelity Selection Strategy",id:"fidelity-selection-strategy",level:3},{value:"1.3 Sim-to-Real Gap",id:"13-sim-to-real-gap",level:2},{value:"Quantifying the Gap",id:"quantifying-the-gap",level:3},{value:"Bridging Strategies",id:"bridging-strategies",level:3},{value:"Best Practices",id:"best-practices",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(i){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...i.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"chapter-1-digital-twin-basics",children:"Chapter 1: Digital Twin Basics"})}),"\n",(0,r.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Understand the digital twin concept and its applications in robotics"}),"\n",(0,r.jsx)(n.li,{children:"Analyze tradeoffs between simulation speed and physical accuracy"}),"\n",(0,r.jsx)(n.li,{children:"Apply strategies to bridge the sim-to-real gap"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"11-digital-twin-concept",children:"1.1 Digital Twin Concept"}),"\n",(0,r.jsx)(n.h3,{id:"definition",children:"Definition"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Digital Twin"}),": A virtual replica of a physical system that mirrors its behavior, appearance, and dynamics in real-time or near-real-time."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"In Robotics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Virtual robot model (URDF/SDF) matches physical robot"}),"\n",(0,r.jsx)(n.li,{children:"Simulated sensors produce data similar to real sensors"}),"\n",(0,r.jsx)(n.li,{children:"Control algorithms tested in simulation transfer to hardware"}),"\n",(0,r.jsx)(n.li,{children:"Environment models (warehouse, terrain) reflect real deployment sites"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"historical-context",children:"Historical Context"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Origins"}),": NASA Apollo program (1960s) - physical duplicates for testing\r\n",(0,r.jsx)(n.strong,{children:"Modern"}),": Software-based virtual replicas with continuous data synchronization"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Evolution in Robotics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"2000s: Basic kinematic simulators (V-REP, Webots)"}),"\n",(0,r.jsx)(n.li,{children:"2010s: Physics-based simulators (Gazebo, MuJoCo)"}),"\n",(0,r.jsx)(n.li,{children:"2020s: GPU-accelerated, photorealistic (Isaac Sim, Unity Simulation)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"use-cases-in-robotics",children:"Use Cases in Robotics"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"1. Development and Testing"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Test algorithms before hardware exists"}),"\n",(0,r.jsx)(n.li,{children:"Validate safety-critical behaviors (emergency stops, collision avoidance)"}),"\n",(0,r.jsx)(n.li,{children:"Iterate rapidly (1000s of trials per day in simulation)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2. Training AI Models"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Reinforcement learning (train policies in parallel simulations)"}),"\n",(0,r.jsx)(n.li,{children:"Synthetic data generation (object detection, segmentation)"}),"\n",(0,r.jsx)(n.li,{children:"Domain randomization (vary lighting, textures, physics for robustness)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"3. Deployment Planning"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simulate warehouse layouts before construction"}),"\n",(0,r.jsx)(n.li,{children:"Test multi-robot coordination"}),"\n",(0,r.jsx)(n.li,{children:"Predict performance metrics (throughput, energy consumption)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"4. Operator Training"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Teleop practice without risking real robot"}),"\n",(0,r.jsx)(n.li,{children:"Emergency scenario training (fire, equipment failure)"}),"\n",(0,r.jsx)(n.li,{children:"VR-based interfaces for remote operation"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"5. Continuous Validation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitor real robot, replay scenarios in simulation"}),"\n",(0,r.jsx)(n.li,{children:"Detect anomalies (real vs simulated behavior divergence)"}),"\n",(0,r.jsx)(n.li,{children:"Predict failures before they occur"}),"\n"]}),"\n",(0,r.jsx)(n.mermaid,{value:'graph TB\r\n    subgraph Physical["Physical System"]\r\n        Robot[Real Robot]\r\n        Sensors[Sensors<br/>Camera, LiDAR, IMU]\r\n        Actuators[Actuators<br/>Motors, Grippers]\r\n    end\r\n\r\n    subgraph Digital["Digital Twin"]\r\n        Model[Virtual Model<br/>URDF, Physics]\r\n        SimSensors[Simulated Sensors]\r\n        Controller[Control Algorithm]\r\n    end\r\n\r\n    subgraph Cloud["Cloud Services"]\r\n        Analytics[Analytics<br/>Prediction, Optimization]\r\n        Storage[Data Storage<br/>Telemetry, Logs]\r\n        Training[ML Training<br/>Policies, Models]\r\n    end\r\n\r\n    Robot --\x3e|Telemetry| Digital\r\n    Sensors --\x3e|Real Data| Digital\r\n    Digital --\x3e|Commands| Actuators\r\n    Digital --\x3e|Predict Behavior| Robot\r\n\r\n    Digital <--\x3e|Data Sync| Cloud\r\n    Cloud --\x3e|Updated Model| Digital\r\n    Cloud --\x3e|OTA Updates| Robot\r\n\r\n    style Physical fill:#ffe1cc\r\n    style Digital fill:#cce1ff\r\n    style Cloud fill:#ccffcc'}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Figure 1.1"}),": Digital twin architecture showing bidirectional data flow between physical robot, virtual model, and cloud services. The digital twin continuously mirrors the physical system, enabling prediction, optimization, and OTA updates."]}),"\n",(0,r.jsx)(n.h3,{id:"digital-twin-vs-simulation",children:"Digital Twin vs Simulation"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Traditional Simulation"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"One-way: Design in simulation \u2192 deploy to hardware"}),"\n",(0,r.jsx)(n.li,{children:"Offline: No connection to real system"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Digital Twin"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Two-way: Real-time data from hardware \u2192 update simulation"}),"\n",(0,r.jsx)(n.li,{children:"Bidirectional sync: Simulation informs hardware decisions"}),"\n",(0,r.jsx)(n.li,{children:"Continuous: Mirrors physical system throughout lifecycle"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Autonomous vehicle fleet"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Traditional: Test in simulator, deploy car"}),"\n",(0,r.jsx)(n.li,{children:"Digital twin: Each car streams telemetry to its twin, simulation predicts maintenance needs, tests OTA updates"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"12-simulation-fidelity-tradeoffs",children:"1.2 Simulation Fidelity Tradeoffs"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fidelity"}),": How accurately the simulation represents reality"]}),"\n",(0,r.jsx)(n.h3,{id:"dimensions-of-fidelity",children:"Dimensions of Fidelity"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"1. Kinematic Fidelity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Low: Simplified geometry (boxes, cylinders)"}),"\n",(0,r.jsx)(n.li,{children:"High: CAD meshes with sub-mm accuracy"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"2. Dynamic Fidelity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Low: Kinematic-only (no forces, instantaneous motion)"}),"\n",(0,r.jsx)(n.li,{children:"Medium: Rigid body dynamics (mass, inertia, collisions)"}),"\n",(0,r.jsx)(n.li,{children:"High: Deformable objects (cloth, fluids, soft robotics)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"3. Sensor Fidelity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Low: Ray-casting for LiDAR, pin-hole camera"}),"\n",(0,r.jsx)(n.li,{children:"High: Ray-tracing with noise models, lens distortion, motion blur"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"4. Visual Fidelity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Low: Flat colors, no lighting"}),"\n",(0,r.jsx)(n.li,{children:"High: Physically-based rendering (PBR), global illumination, shadows"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"5. Computational Fidelity"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Low: Simplified control loops"}),"\n",(0,r.jsx)(n.li,{children:"High: Hardware-in-the-loop (real embedded code)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"speed-vs-accuracy",children:"Speed vs Accuracy"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fast Simulation"})," (low fidelity):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": Reinforcement learning (need 1M+ episodes)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Isaac Gym - 10,000 parallel robots at 100x real-time"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff"}),": Simplified physics, less realistic sensor noise"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Accurate Simulation"})," (high fidelity):"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use case"}),": Hardware validation, safety testing"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Example"}),": Gazebo with DART physics - realistic contact dynamics"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tradeoff"}),": Slower than real-time (0.1x-0.5x)"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Real-Time Requirement"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Human-in-loop: Must run \u22651x real-time (operator sees immediate feedback)"}),"\n",(0,r.jsx)(n.li,{children:"Batch training: Can run slower (overnight training runs)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"fidelity-selection-strategy",children:"Fidelity Selection Strategy"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 High Fidelity (Slow)                           \u2502\r\n\u2502 - Safety validation                            \u2502\r\n\u2502 - Hardware-specific tuning (PID gains)         \u2502\r\n\u2502 - Operator training                            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                      \u2195\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Medium Fidelity (Real-time)                    \u2502\r\n\u2502 - Algorithm development                        \u2502\r\n\u2502 - Multi-robot coordination                     \u2502\r\n\u2502 - ROS 2 integration testing                    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                      \u2195\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Low Fidelity (Fast)                            \u2502\r\n\u2502 - Reinforcement learning                       \u2502\r\n\u2502 - Path planning in large spaces                \u2502\r\n\u2502 - Monte Carlo analysis (1000s of trials)       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Adaptive Fidelity"}),": Start low (explore design space), increase for final validation"]}),"\n",(0,r.jsx)(n.h2,{id:"13-sim-to-real-gap",children:"1.3 Sim-to-Real Gap"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Problem"}),": Policies trained in simulation fail on real robots"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Causes"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics inaccuracies"}),": Contact dynamics, friction, deformation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Unmodeled effects"}),": Cable drag, actuator backlash, sensor drift"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Simplified perception"}),": Perfect object poses in sim, noisy estimates in reality"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Deterministic sim"}),": Real world has stochastic disturbances (wind, uneven floors)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"quantifying-the-gap",children:"Quantifying the Gap"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Metrics"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Task success rate: 95% in sim, 60% on hardware \u2192 35% gap"}),"\n",(0,r.jsx)(n.li,{children:"Trajectory error: Mean deviation between sim and real execution"}),"\n",(0,r.jsx)(n.li,{children:"Perception accuracy: Object detection mAP difference"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example (Grasping)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Sim: 100% success (known object pose, perfect gripper control)"}),"\n",(0,r.jsx)(n.li,{children:"Real: 70% success (pose estimation errors, contact uncertainties)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"bridging-strategies",children:"Bridging Strategies"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"1. Domain Randomization"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Idea"}),": Vary simulation parameters so policy learns robust features"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Randomize"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Physics"}),": Friction (0.3-0.9), object mass (\xb120%), joint damping"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Visual"}),": Lighting intensity, object textures, camera exposure"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Geometry"}),": Object sizes, positions, robot link lengths (within tolerances)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Dynamics"}),": Action delays, sensor noise levels"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Example (Cube stacking)"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"# Randomize cube properties\r\ncube_mass = np.random.uniform(0.05, 0.15)  # kg\r\nfriction = np.random.uniform(0.4, 1.0)\r\ntexture = random.choice(textures)  # Different colors/patterns\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Result"}),": Policy sees diverse scenarios, generalizes to real world variability"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"2. System Identification"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Idea"}),": Measure real robot parameters, update simulation to match"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Process"}),":"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Run calibration experiments on hardware (measure friction, inertia)"}),"\n",(0,r.jsx)(n.li,{children:"Fit simulation parameters to match observed behavior"}),"\n",(0,r.jsx)(n.li,{children:"Iteratively refine (residual minimization)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Tools"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Motor torque calibration (apply known torque, measure angle)"}),"\n",(0,r.jsx)(n.li,{children:"Contact friction tests (sliding blocks on surfaces)"}),"\n",(0,r.jsx)(n.li,{children:"Sensor noise characterization (static environment, measure variance)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Limitation"}),": Time-consuming, requires hardware access"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"3. Sim-to-Real Transfer Learning"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Fine-tuning"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Train policy in simulation (millions of samples)"}),"\n",(0,r.jsx)(n.li,{children:"Collect small real-world dataset (1000s of samples)"}),"\n",(0,r.jsx)(n.li,{children:"Fine-tune policy on real data (update last layers)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Advantage"}),": Leverages sim for exploration, real data for final polish"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"4. Reality Gap-Aware Training"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Adversarial Training"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Train discriminator to detect sim vs real data"}),"\n",(0,r.jsx)(n.li,{children:"Policy learns features that work in both domains"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Invariant Representations"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Learn state representations invariant to sim/real differences"}),"\n",(0,r.jsx)(n.li,{children:"Example: Depth images (less affected by lighting than RGB)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"5. Hybrid Approaches"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Hardware-in-the-Loop (HIL)"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Real robot actuators + simulated environment"}),"\n",(0,r.jsx)(n.li,{children:"Or: Real sensors + simulated robot"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Digital Twin Feedback"}),":"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Run policy on real robot, stream data to sim"}),"\n",(0,r.jsx)(n.li,{children:"If real diverges from sim prediction \u2192 trigger safety stop, investigate"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Start simple"}),": Test sim-to-real on simple tasks (move to point) before complex (manipulation)"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Measure gap"}),": Log sim and real metrics, track convergence over development"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Incremental reality"}),": Sim \u2192 sim with randomization \u2192 simplified hardware setup \u2192 full deployment"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety margins"}),": If sim predicts 70% success, expect 50-60% on hardware"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Iterative"}),": Sim \u2192 real \u2192 analyze failures \u2192 improve sim \u2192 repeat"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Digital Twin"}),": Virtual replica for development, training, deployment planning, continuous validation\r\n",(0,r.jsx)(n.strong,{children:"Fidelity Tradeoffs"}),": Fast (RL, Monte Carlo) \u2194 Accurate (safety, tuning)\r\n",(0,r.jsx)(n.strong,{children:"Sim-to-Real Gap"}),": Bridged via domain randomization, system ID, transfer learning, hybrid approaches"]}),"\n",(0,r.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exercise 1.1"}),": Design a digital twin system for a warehouse robot fleet. Specify:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"What data flows from physical robots to digital twins"}),"\n",(0,r.jsx)(n.li,{children:"What predictions the twin makes (maintenance, performance)"}),"\n",(0,r.jsx)(n.li,{children:"How the twin influences robot behavior (OTA updates, routing optimization)"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exercise 1.2"}),": For a pick-and-place robot, determine appropriate simulation fidelity levels for:"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Initial algorithm development (RL policy training)"}),"\n",(0,r.jsx)(n.li,{children:"PID gain tuning for gripper force control"}),"\n",(0,r.jsx)(n.li,{children:"Safety validation before hardware deployment\r\nJustify each choice with speed/accuracy tradeoffs."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exercise 1.3"}),": Implement domain randomization for a cube stacking task. Randomize:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cube mass (\xb120%)"}),"\n",(0,r.jsx)(n.li,{children:"Surface friction (0.4-1.0)"}),"\n",(0,r.jsx)(n.li,{children:"Lighting direction and intensity\r\nMeasure sim-to-real transfer by comparing success rates in simulation vs on real robot."}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Exercise 1.4"}),": Conduct system identification for a mobile robot. Measure wheel friction by applying known torques and recording velocities. Update simulation parameters to match. Compare trajectories before and after calibration."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Next"}),": Chapter 2 covers Gazebo physics engines, contact modeling, and sensor simulation."]})]})}function h(i={}){const{wrapper:n}={...(0,l.R)(),...i.components};return n?(0,r.jsx)(n,{...i,children:(0,r.jsx)(d,{...i})}):d(i)}}}]);