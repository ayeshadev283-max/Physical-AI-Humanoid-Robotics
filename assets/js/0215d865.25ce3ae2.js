"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[2224],{28453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>a});var i=n(96540);const s={},o=i.createContext(s);function t(e){const r=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:t(e.components),i.createElement(o.Provider,{value:r},e.children)}},84679:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"chapters/module-1-ros2/tf-urdf","title":"Chapter 3: TF and URDF","description":"Coordinate transforms and robot description formats","source":"@site/docs/chapters/module-1-ros2/03-tf-urdf.md","sourceDirName":"chapters/module-1-ros2","slug":"/chapters/module-1-ros2/tf-urdf","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapters/module-1-ros2/tf-urdf","draft":false,"unlisted":false,"editUrl":"https://github.com/ayeshadev283-max/Physical-AI-Humanoid-Robotics/tree/main/docs/chapters/module-1-ros2/03-tf-urdf.md","tags":[{"inline":true,"label":"ros2","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/ros-2"},{"inline":true,"label":"tf2","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/tf-2"},{"inline":true,"label":"urdf","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/urdf"},{"inline":true,"label":"xacro","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/xacro"},{"inline":true,"label":"robot-description","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/robot-description"}],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Chapter 3: TF and URDF","description":"Coordinate transforms and robot description formats","tags":["ros2","tf2","urdf","xacro","robot-description"]},"sidebar":"bookSidebar","previous":{"title":"Chapter 2: Nodes, Topics, Services, Actions","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapters/module-1-ros2/nodes-topics-services-actions"},"next":{"title":"Chapter 4: Simulation Pipeline","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapters/module-1-ros2/simulation-pipeline"}}');var s=n(74848),o=n(28453);const t={sidebar_position:3,title:"Chapter 3: TF and URDF",description:"Coordinate transforms and robot description formats",tags:["ros2","tf2","urdf","xacro","robot-description"]},a="Chapter 3: TF and URDF",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"3.1 Transform Trees (TF2)",id:"31-transform-trees-tf2",level:2},{value:"Why TF2?",id:"why-tf2",level:3},{value:"TF2 Concepts",id:"tf2-concepts",level:3},{value:"TF2 API",id:"tf2-api",level:3},{value:"Time Travel",id:"time-travel",level:3},{value:"Static vs Dynamic Transforms",id:"static-vs-dynamic-transforms",level:3},{value:"Debugging TF",id:"debugging-tf",level:3},{value:"3.2 Robot Description (URDF/Xacro, SDF)",id:"32-robot-description-urdfxacro-sdf",level:2},{value:"URDF (Unified Robot Description Format)",id:"urdf-unified-robot-description-format",level:3},{value:"Xacro (XML Macros)",id:"xacro-xml-macros",level:3},{value:"SDF (Simulation Description Format)",id:"sdf-simulation-description-format",level:3},{value:"3.3 URDF Best Practices",id:"33-urdf-best-practices",level:2},{value:"Modularity",id:"modularity",level:3},{value:"Parameterization",id:"parameterization",level:3},{value:"Coordinate Frame Conventions",id:"coordinate-frame-conventions",level:3},{value:"Validation",id:"validation",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"chapter-3-tf-and-urdf",children:"Chapter 3: TF and URDF"})}),"\n",(0,s.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"Use TF2 to manage coordinate transforms in robot systems"}),"\n",(0,s.jsx)(r.li,{children:"Design robot descriptions using URDF and Xacro"}),"\n",(0,s.jsx)(r.li,{children:"Apply best practices for modular robot descriptions"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"31-transform-trees-tf2",children:"3.1 Transform Trees (TF2)"}),"\n",(0,s.jsx)(r.h3,{id:"why-tf2",children:"Why TF2?"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Problem"}),": Robots have many coordinate frames (world, base, sensors, end-effector)"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Example"}),": To grasp an object detected by a camera:"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:["Camera sees object at (x, y, z) in ",(0,s.jsx)(r.code,{children:"camera_frame"})]}),"\n",(0,s.jsxs)(r.li,{children:["Need position in ",(0,s.jsx)(r.code,{children:"base_link"})," for arm planning"]}),"\n",(0,s.jsxs)(r.li,{children:["TF2 automatically transforms: ",(0,s.jsx)(r.code,{children:"camera_frame"})," \u2192 ",(0,s.jsx)(r.code,{children:"base_link"})]}),"\n"]}),"\n",(0,s.jsx)(r.mermaid,{value:"graph TD\r\n    map[map<br/>World fixed frame] --\x3e odom[odom<br/>Local navigation]\r\n    odom --\x3e base_link[base_link<br/>Robot center]\r\n\r\n    base_link --\x3e base_footprint[base_footprint<br/>Ground projection]\r\n    base_link --\x3e torso[torso]\r\n\r\n    torso --\x3e head[head]\r\n    head --\x3e camera_link[camera_link<br/>Camera optical frame]\r\n    head --\x3e lidar_link[lidar_link]\r\n\r\n    torso --\x3e left_shoulder[left_shoulder]\r\n    left_shoulder --\x3e left_elbow[left_elbow]\r\n    left_elbow --\x3e left_wrist[left_wrist]\r\n    left_wrist --\x3e left_gripper[left_gripper]\r\n\r\n    torso --\x3e right_shoulder[right_shoulder]\r\n    right_shoulder --\x3e right_elbow[right_elbow]\r\n    right_elbow --\x3e right_wrist[right_wrist]\r\n    right_wrist --\x3e right_gripper[right_gripper]\r\n\r\n    base_link --\x3e left_hip[left_hip]\r\n    left_hip --\x3e left_knee[left_knee]\r\n    left_knee --\x3e left_ankle[left_ankle]\r\n    left_ankle --\x3e left_foot[left_foot]\r\n\r\n    base_link --\x3e right_hip[right_hip]\r\n    right_hip --\x3e right_knee[right_knee]\r\n    right_knee --\x3e right_ankle[right_ankle]\r\n    right_ankle --\x3e right_foot[right_foot]\r\n\r\n    style map fill:#ffffcc\r\n    style odom fill:#ccffff\r\n    style base_link fill:#ccffcc\r\n    style camera_link fill:#ffcccc"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Figure 3.1"}),": TF tree for a humanoid robot. The tree has a single root (",(0,s.jsx)(r.code,{children:"map"}),"), with ",(0,s.jsx)(r.code,{children:"odom"})," for local odometry and ",(0,s.jsx)(r.code,{children:"base_link"})," as the robot's reference frame. Sensors (camera, lidar) and body parts (arms, legs) are child frames. TF2 automatically computes transforms between any two frames (e.g., ",(0,s.jsx)(r.code,{children:"camera_link"})," to ",(0,s.jsx)(r.code,{children:"left_gripper"})," for visual servoing)."]}),"\n",(0,s.jsx)(r.h3,{id:"tf2-concepts",children:"TF2 Concepts"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Frame"}),": Coordinate system (origin + orientation)"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Transform"}),": Translation + rotation between two frames"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Tree Structure"}),": Frames form a tree (one parent, multiple children)"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Root: ",(0,s.jsx)(r.code,{children:"world"})," or ",(0,s.jsx)(r.code,{children:"map"})]}),"\n",(0,s.jsxs)(r.li,{children:["Mobile base: ",(0,s.jsx)(r.code,{children:"odom"})," \u2192 ",(0,s.jsx)(r.code,{children:"base_link"})]}),"\n",(0,s.jsxs)(r.li,{children:["Sensors: ",(0,s.jsx)(r.code,{children:"base_link"})," \u2192 ",(0,s.jsx)(r.code,{children:"camera_link"}),", ",(0,s.jsx)(r.code,{children:"lidar_link"})]}),"\n",(0,s.jsxs)(r.li,{children:["Manipulator: ",(0,s.jsx)(r.code,{children:"base_link"})," \u2192 ",(0,s.jsx)(r.code,{children:"shoulder"})," \u2192 ",(0,s.jsx)(r.code,{children:"elbow"})," \u2192 ",(0,s.jsx)(r.code,{children:"wrist"})," \u2192 ",(0,s.jsx)(r.code,{children:"end_effector"})]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"tf2-api",children:"TF2 API"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Broadcasting Transforms"})," (Python):"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"from tf2_ros import TransformBroadcaster\r\nfrom geometry_msgs.msg import TransformStamped\r\n\r\nclass OdometryPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__('odometry_publisher')\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n\r\n    def publish_odometry(self, x, y, theta):\r\n        t = TransformStamped()\r\n        t.header.stamp = self.get_clock().now().to_msg()\r\n        t.header.frame_id = 'odom'\r\n        t.child_frame_id = 'base_link'\r\n        t.transform.translation.x = x\r\n        t.transform.translation.y = y\r\n        t.transform.translation.z = 0.0\r\n\r\n        # Convert yaw to quaternion\r\n        q = quaternion_from_euler(0, 0, theta)\r\n        t.transform.rotation.x = q[0]\r\n        t.transform.rotation.y = q[1]\r\n        t.transform.rotation.z = q[2]\r\n        t.transform.rotation.w = q[3]\r\n\r\n        self.tf_broadcaster.sendTransform(t)\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Looking Up Transforms"})," (C++):"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-cpp",children:'#include <tf2_ros/transform_listener.h>\r\n#include <tf2_ros/buffer.h>\r\n\r\nstd::shared_ptr<tf2_ros::Buffer> tf_buffer;\r\nstd::shared_ptr<tf2_ros::TransformListener> tf_listener;\r\n\r\ntf_buffer = std::make_shared<tf2_ros::Buffer>(node->get_clock());\r\ntf_listener = std::make_shared<tf2_ros::TransformListener>(*tf_buffer);\r\n\r\ntry {\r\n    auto transform = tf_buffer->lookupTransform(\r\n        "base_link", "camera_link",\r\n        tf2::TimePointZero);  // Latest available\r\n    // Use transform...\r\n} catch (tf2::TransformException &ex) {\r\n    RCLCPP_WARN(node->get_logger(), "TF lookup failed: %s", ex.what());\r\n}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"time-travel",children:"Time Travel"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Problem"}),": Transforms change over time (robot moves)"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Solution"}),": TF2 stores history (default: 10 seconds)"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"# Get transform at specific time\r\npast_time = rclpy.time.Time(seconds=5.0)\r\ntransform = tf_buffer.lookup_transform(\r\n    'map', 'base_link',\r\n    past_time,\r\n    timeout=rclpy.duration.Duration(seconds=1.0))\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Use Case"}),": Localization - where was the robot when it saw this landmark?"]}),"\n",(0,s.jsx)(r.h3,{id:"static-vs-dynamic-transforms",children:"Static vs Dynamic Transforms"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Static"}),": Fixed (sensor mounted on robot)"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"ros2 run tf2_ros static_transform_publisher 0 0 0.5 0 0 0 base_link camera_link\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Dynamic"}),": Changes (odometry, joint states)"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Broadcast at sensor rate (IMU: 100Hz, odometry: 50Hz)"}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"debugging-tf",children:"Debugging TF"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Visualize tree\r\nros2 run tf2_tools view_frames\r\n\r\n# Check specific transform\r\nros2 run tf2_ros tf2_echo base_link end_effector\r\n\r\n# View in RViz\r\nrviz2\r\n# Add TF display, set fixed frame to 'world'\n"})}),"\n",(0,s.jsx)(r.h2,{id:"32-robot-description-urdfxacro-sdf",children:"3.2 Robot Description (URDF/Xacro, SDF)"}),"\n",(0,s.jsx)(r.h3,{id:"urdf-unified-robot-description-format",children:"URDF (Unified Robot Description Format)"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"XML format"})," defining robot structure:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Links: Rigid bodies (visual, collision, inertial)"}),"\n",(0,s.jsx)(r.li,{children:"Joints: Connections (revolute, prismatic, fixed, continuous)"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Simple Example"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="simple_robot">\r\n  <link name="base_link">\r\n    <visual>\r\n      <geometry>\r\n        <box size="0.6 0.4 0.2"/>\r\n      </geometry>\r\n      <material name="blue">\r\n        <color rgba="0 0 0.8 1"/>\r\n      </material>\r\n    </visual>\r\n    <collision>\r\n      <geometry>\r\n        <box size="0.6 0.4 0.2"/>\r\n      </geometry>\r\n    </collision>\r\n    <inertial>\r\n      <mass value="10.0"/>\r\n      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <link name="wheel_left">\r\n    <visual>\r\n      <geometry>\r\n        <cylinder radius="0.1" length="0.05"/>\r\n      </geometry>\r\n    </visual>\r\n    <inertial>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="base_to_wheel_left" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="wheel_left"/>\r\n    <origin xyz="0 0.25 -0.1" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n  </joint>\r\n</robot>\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Joint Types"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"fixed"}),": Welded (sensor mounts)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"revolute"}),": Hinge with limits (elbow: -90\xb0 to +90\xb0)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"continuous"}),": Unlimited rotation (wheels)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"prismatic"}),": Linear slide (elevator, gripper)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"floating"}),": 6-DOF (rarely used, for simulating free-flying objects)"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"xacro-xml-macros",children:"Xacro (XML Macros)"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Problem"}),": URDF is verbose and repetitive"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Solution"}),": Xacro adds variables, math, macros"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<robot name="modular_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n  \x3c!-- Parameters --\x3e\r\n  <xacro:property name="wheel_radius" value="0.1"/>\r\n  <xacro:property name="wheel_width" value="0.05"/>\r\n  <xacro:property name="base_width" value="0.4"/>\r\n\r\n  \x3c!-- Macro for wheels (reusable) --\x3e\r\n  <xacro:macro name="wheel" params="prefix x_pos y_pos">\r\n    <link name="${prefix}_wheel">\r\n      <visual>\r\n        <geometry>\r\n          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>\r\n        </geometry>\r\n      </visual>\r\n      <inertial>\r\n        <mass value="0.5"/>\r\n        <inertia ixx="0.01" ixy="0" ixz="0" iyy="0.01" iyz="0" izz="0.01"/>\r\n      </inertial>\r\n    </link>\r\n\r\n    <joint name="base_to_${prefix}_wheel" type="continuous">\r\n      <parent link="base_link"/>\r\n      <child link="${prefix}_wheel"/>\r\n      <origin xyz="${x_pos} ${y_pos} ${-wheel_radius}" rpy="0 0 0"/>\r\n      <axis xyz="0 1 0"/>\r\n    </joint>\r\n  </xacro:macro>\r\n\r\n  \x3c!-- Use macro --\x3e\r\n  <xacro:wheel prefix="left" x_pos="0" y_pos="${base_width/2}"/>\r\n  <xacro:wheel prefix="right" x_pos="0" y_pos="${-base_width/2}"/>\r\n</robot>\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Convert to URDF"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"xacro robot.urdf.xacro > robot.urdf\n"})}),"\n",(0,s.jsx)(r.h3,{id:"sdf-simulation-description-format",children:"SDF (Simulation Description Format)"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Gazebo-native format"})," (more expressive than URDF):"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Supports closed kinematic chains"}),"\n",(0,s.jsx)(r.li,{children:"Plugin system"}),"\n",(0,s.jsx)(r.li,{children:"Nested models (multi-robot scenarios)"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"ROS 2 Integration"}),": ",(0,s.jsx)(r.code,{children:"urdf_to_sdf"})," converter, or use URDF directly in Gazebo"]}),"\n",(0,s.jsx)(r.h2,{id:"33-urdf-best-practices",children:"3.3 URDF Best Practices"}),"\n",(0,s.jsx)(r.h3,{id:"modularity",children:"Modularity"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Principle"}),": Separate robot into composable modules"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Structure"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"robot_description/\r\n\u251c\u2500\u2500 urdf/\r\n\u2502   \u251c\u2500\u2500 robot.urdf.xacro           # Top-level assembly\r\n\u2502   \u251c\u2500\u2500 base/\r\n\u2502   \u2502   \u2514\u2500\u2500 base.urdf.xacro        # Mobile base\r\n\u2502   \u251c\u2500\u2500 sensors/\r\n\u2502   \u2502   \u251c\u2500\u2500 lidar.urdf.xacro\r\n\u2502   \u2502   \u2514\u2500\u2500 camera.urdf.xacro\r\n\u2502   \u2514\u2500\u2500 manipulator/\r\n\u2502       \u2514\u2500\u2500 arm.urdf.xacro\r\n\u2514\u2500\u2500 meshes/\r\n    \u251c\u2500\u2500 base_link.stl\r\n    \u2514\u2500\u2500 gripper.stl\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Top-level File"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:'<robot name="mobile_manipulator" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n  <xacro:include filename="base/base.urdf.xacro"/>\r\n  <xacro:include filename="sensors/lidar.urdf.xacro"/>\r\n  <xacro:include filename="manipulator/arm.urdf.xacro"/>\r\n\r\n  \x3c!-- Assemble --\x3e\r\n  <xacro:mobile_base prefix=""/>\r\n  <xacro:lidar parent="base_link" xyz="0.2 0 0.3"/>\r\n  <xacro:robot_arm parent="base_link" xyz="0 0 0.2"/>\r\n</robot>\n'})}),"\n",(0,s.jsx)(r.h3,{id:"parameterization",children:"Parameterization"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Use properties for tunable values"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:'<xacro:arg name="robot_mass" default="50.0"/>\r\n<xacro:arg name="wheel_diameter" default="0.2"/>\r\n<xacro:arg name="use_gpu_lidar" default="false"/>\r\n\r\n<mass value="$(arg robot_mass)"/>\n'})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Load with arguments"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"ros2 launch robot_bringup robot.launch.py robot_mass:=60.0 use_gpu_lidar:=true\n"})}),"\n",(0,s.jsx)(r.h3,{id:"coordinate-frame-conventions",children:"Coordinate Frame Conventions"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"REP 103"})," (ROS coordinate frames):"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"X: Forward"}),"\n",(0,s.jsx)(r.li,{children:"Y: Left"}),"\n",(0,s.jsx)(r.li,{children:"Z: Up"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"REP 105"})," (frame names):"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"map"}),": World frame (static, localization reference)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"odom"}),": Local odometry frame (continuous, drifts over time)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"base_link"}),": Robot center (origin for planning)"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.code,{children:"base_footprint"}),": Projection of ",(0,s.jsx)(r.code,{children:"base_link"})," on ground (Z=0)"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"validation",children:"Validation"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Check URDF for errors\r\ncheck_urdf robot.urdf\r\n\r\n# Visualize in RViz\r\nros2 launch urdf_tutorial display.launch.py model:=robot.urdf\r\n\r\n# Test joint limits\r\nros2 run joint_state_publisher_gui joint_state_publisher_gui\n"})}),"\n",(0,s.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"TF2"}),": Manages coordinate transforms, time-aware, tree structure\r\n",(0,s.jsx)(r.strong,{children:"URDF"}),": Robot description (links, joints, visual, collision, inertial)\r\n",(0,s.jsx)(r.strong,{children:"Xacro"}),": Modular, parameterized URDF with macros\r\n",(0,s.jsx)(r.strong,{children:"Best Practices"}),": Modularity, parameterization, REP compliance"]}),"\n",(0,s.jsx)(r.h2,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Exercise 3.1"}),": Write a TF broadcaster that publishes the transform from ",(0,s.jsx)(r.code,{children:"map"})," to ",(0,s.jsx)(r.code,{children:"odom"})," based on a simulated robot position (x, y, theta). Update the transform at 50 Hz. Verify with ",(0,s.jsx)(r.code,{children:"ros2 run tf2_ros tf2_echo map odom"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Exercise 3.2"}),": Create a URDF for a simple 2-DOF robot arm with:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Base link (fixed to ground)"}),"\n",(0,s.jsx)(r.li,{children:"Shoulder joint (revolute, \xb190\xb0)"}),"\n",(0,s.jsx)(r.li,{children:"Elbow joint (revolute, \xb1120\xb0)"}),"\n",(0,s.jsx)(r.li,{children:"End effector link"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["Use Xacro to parameterize link lengths. Visualize in RViz with ",(0,s.jsx)(r.code,{children:"joint_state_publisher_gui"}),"."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Exercise 3.3"}),": Use TF2 to transform a point detected by a camera (in ",(0,s.jsx)(r.code,{children:"camera_link"})," frame) to the robot's ",(0,s.jsx)(r.code,{children:"base_link"})," frame. Given a point at (0.5, 0, 1.0) in camera coordinates, compute its position relative to the base. Account for the camera being mounted 0.3m above and 0.2m forward of the base."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Exercise 3.4"}),": Refactor a monolithic URDF into modular Xacro files. Separate the mobile base, sensors (camera, LiDAR), and manipulator into individual files. Create a top-level assembly file that includes all modules."]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Next"}),": Chapter 4 integrates ROS 2 with simulation (Gazebo, launch files, development workflow)."]})]})}function h(e={}){const{wrapper:r}={...(0,o.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);