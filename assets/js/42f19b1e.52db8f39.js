"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[9165],{28453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>t});var r=i(96540);const a={},s=r.createContext(a);function o(n){const e=r.useContext(s);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),r.createElement(s.Provider,{value:e},n.children)}},81740:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>t,default:()=>m,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"chapters/module-3-isaac/sim-to-real","title":"Chapter 3: Sim-to-Real Transfer","description":"Domain randomization, system identification, and transfer learning in Isaac","source":"@site/docs/chapters/module-3-isaac/03-sim-to-real.md","sourceDirName":"chapters/module-3-isaac","slug":"/chapters/module-3-isaac/sim-to-real","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapters/module-3-isaac/sim-to-real","draft":false,"unlisted":false,"editUrl":"https://github.com/ayeshadev283-max/Physical-AI-Humanoid-Robotics/tree/main/docs/chapters/module-3-isaac/03-sim-to-real.md","tags":[{"inline":true,"label":"sim-to-real","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/sim-to-real"},{"inline":true,"label":"domain-randomization","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/domain-randomization"},{"inline":true,"label":"isaac-sim","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/isaac-sim"},{"inline":true,"label":"transfer-learning","permalink":"/Physical-AI-Humanoid-Robotics/docs/tags/transfer-learning"}],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Chapter 3: Sim-to-Real Transfer","description":"Domain randomization, system identification, and transfer learning in Isaac","tags":["sim-to-real","domain-randomization","isaac-sim","transfer-learning"]},"sidebar":"bookSidebar","previous":{"title":"Chapter 2: Isaac ROS Perception and Planning","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapters/module-3-isaac/perception-planning"},"next":{"title":"Chapter 4: Control Loops with RL and IL","permalink":"/Physical-AI-Humanoid-Robotics/docs/chapters/module-3-isaac/control-loops"}}');var a=i(74848),s=i(28453);const o={sidebar_position:3,title:"Chapter 3: Sim-to-Real Transfer",description:"Domain randomization, system identification, and transfer learning in Isaac",tags:["sim-to-real","domain-randomization","isaac-sim","transfer-learning"]},t="Chapter 3: Sim-to-Real Transfer",l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"3.1 Domain Randomization in Isaac Sim",id:"31-domain-randomization-in-isaac-sim",level:2},{value:"Visual Randomization",id:"visual-randomization",level:3},{value:"Physics Randomization",id:"physics-randomization",level:3},{value:"Structured Randomization",id:"structured-randomization",level:3},{value:"3.2 System Identification Workflows",id:"32-system-identification-workflows",level:2},{value:"Parameter Estimation",id:"parameter-estimation",level:3},{value:"Automated Calibration",id:"automated-calibration",level:3},{value:"3.3 Transfer Learning Strategies",id:"33-transfer-learning-strategies",level:2},{value:"Pre-training in Simulation",id:"pre-training-in-simulation",level:3},{value:"Sim-to-Real Adaptation",id:"sim-to-real-adaptation",level:3},{value:"Residual Learning",id:"residual-learning",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"chapter-3-sim-to-real-transfer",children:"Chapter 3: Sim-to-Real Transfer"})}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Apply domain randomization techniques in Isaac Sim"}),"\n",(0,a.jsx)(e.li,{children:"Conduct system identification workflows"}),"\n",(0,a.jsx)(e.li,{children:"Implement transfer learning strategies for robot policies"}),"\n"]}),"\n",(0,a.jsx)(e.mermaid,{value:'graph TB\r\n    subgraph Simulation["Isaac Sim Training"]\r\n        DR[Domain Randomization<br/>Textures, Lighting, Physics]\r\n        Train[Train Policy<br/>PPO, 1M steps]\r\n        Validate[Validate in Sim<br/>Success rate]\r\n    end\r\n\r\n    subgraph Transfer["Transfer Process"]\r\n        SysID[System Identification<br/>Measure real params]\r\n        FineTune[Fine-Tune Policy<br/>Real robot, 10k steps]\r\n    end\r\n\r\n    subgraph Deployment["Real Robot"]\r\n        Deploy[Deploy Policy]\r\n        Monitor[Monitor Performance]\r\n        Feedback[Collect Failure Cases]\r\n    end\r\n\r\n    DR --\x3e Train\r\n    Train --\x3e Validate\r\n    Validate --\x3e|Good| Transfer\r\n    Validate --\x3e|Poor| DR\r\n\r\n    SysID --\x3e FineTune\r\n    FineTune --\x3e Deploy\r\n    Deploy --\x3e Monitor\r\n    Monitor --\x3e|Failures| Feedback\r\n    Feedback --\x3e|Update Sim| DR\r\n\r\n    style Simulation fill:#cce1ff\r\n    style Transfer fill:#ffffcc\r\n    style Deployment fill:#ccffcc'}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Figure 3.1"}),": Sim-to-real workflow showing iterative process: train in simulation with domain randomization, transfer to real robot with system ID and fine-tuning, monitor performance and update simulation based on failures."]}),"\n",(0,a.jsx)(e.h2,{id:"31-domain-randomization-in-isaac-sim",children:"3.1 Domain Randomization in Isaac Sim"}),"\n",(0,a.jsx)(e.h3,{id:"visual-randomization",children:"Visual Randomization"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Randomize Textures"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import omni.replicator.core as rep\r\n\r\n# Randomize object materials\r\nwith rep.trigger.on_frame():\r\n    rep.randomizer.materials(\r\n        objects=rep.get.prims(path_pattern="/World/Objects/*"),\r\n        materials=rep.utils.get_materials("materials/"),\r\n        project_uvw=True\r\n    )\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Randomize Lighting"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Random light positions and intensities\r\nwith rep.trigger.on_frame():\r\n    rep.randomizer.light(\r\n        lights=rep.get.prims(semantics=[("class", "light")]),\r\n        intensity=(500, 3000),\r\n        temperature=(2500, 7500),\r\n        position=((-10, 10), (2, 5), (-10, 10))\r\n    )\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Camera Randomization"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Random camera pose, FOV, exposure\r\nwith rep.trigger.on_frame():\r\n    rep.randomizer.camera(\r\n        cameras=rep.get.prims(semantics=[("class", "camera")]),\r\n        focal_length=(18, 85),  # mm\r\n        f_stop=(1.4, 16),\r\n        focus_distance=(0.5, 10)\r\n    )\n'})}),"\n",(0,a.jsx)(e.h3,{id:"physics-randomization",children:"Physics Randomization"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Object Properties"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'from omni.isaac.core.utils.prims import get_prim_at_path\r\nfrom pxr import UsdPhysics\r\n\r\ncube_prim = get_prim_at_path("/World/Cube")\r\nphysics_api = UsdPhysics.RigidBodyAPI.Apply(cube_prim)\r\n\r\n# Randomize mass\r\nimport random\r\nmass = random.uniform(0.05, 0.15)  # kg\r\nphysics_api.CreateMassAttr(mass)\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Friction"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"physics_material = UsdPhysics.MaterialAPI.Apply(cube_prim)\r\nphysics_material.CreateStaticFrictionAttr(random.uniform(0.3, 0.9))\r\nphysics_material.CreateDynamicFrictionAttr(random.uniform(0.2, 0.8))\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Joint Dynamics"}),":"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Randomize joint damping/stiffness\r\njoint = robot.get_articulation().get_joints_by_name("elbow_joint")[0]\r\njoint.set_joint_damping(random.uniform(0.1, 1.0))\r\njoint.set_joint_stiffness(random.uniform(50, 200))\n'})}),"\n",(0,a.jsx)(e.h3,{id:"structured-randomization",children:"Structured Randomization"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Curriculum Learning"}),": Progressively harder randomization"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class DomainRandomizer:\r\n    def __init__(self, difficulty=0.0):\r\n        self.difficulty = difficulty  # 0.0 (easy) to 1.0 (hard)\r\n\r\n    def randomize_mass(self, nominal_mass):\r\n        variation = 0.05 + 0.45 * self.difficulty  # 5% to 50% variation\r\n        return nominal_mass * random.uniform(1 - variation, 1 + variation)\r\n\r\n    def randomize_friction(self):\r\n        if self.difficulty < 0.5:\r\n            return random.uniform(0.6, 0.9)  # Easy: high friction\r\n        else:\r\n            return random.uniform(0.1, 0.9)  # Hard: full range\r\n\r\n# Increase difficulty during training\r\nrandomizer = DomainRandomizer(difficulty=0.0)\r\nfor epoch in range(100):\r\n    randomizer.difficulty = min(1.0, epoch / 100.0)\r\n    # Train policy with current difficulty\n"})}),"\n",(0,a.jsx)(e.h2,{id:"32-system-identification-workflows",children:"3.2 System Identification Workflows"}),"\n",(0,a.jsx)(e.h3,{id:"parameter-estimation",children:"Parameter Estimation"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Workflow"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Run experiments on real robot (collect data)"}),"\n",(0,a.jsx)(e.li,{children:"Fit simulation parameters to match observations"}),"\n",(0,a.jsx)(e.li,{children:"Validate: Run same experiment in sim, compare"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Example"})," (Friction Identification):"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Step 1"}),": Real robot data collection"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# Apply known torques, measure joint velocities\r\ntorques = [0.1, 0.2, 0.3, 0.5, 1.0]  # N\xb7m\r\nmeasured_velocities = []  # rad/s\r\n\r\nfor torque in torques:\r\n    robot.apply_joint_torque("elbow", torque)\r\n    time.sleep(1.0)  # Let reach steady state\r\n    vel = robot.get_joint_velocity("elbow")\r\n    measured_velocities.append(vel)\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Step 2"}),": Simulation parameter fitting"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\r\nfrom scipy.optimize import minimize\r\n\r\ndef simulate_joint(friction_coeff, torque):\r\n    # Simple friction model: torque = friction * velocity\r\n    # At steady state: applied_torque = friction * velocity\r\n    return torque / friction_coeff\r\n\r\ndef error_function(friction_coeff):\r\n    errors = []\r\n    for i, torque in enumerate(torques):\r\n        sim_vel = simulate_joint(friction_coeff, torque)\r\n        real_vel = measured_velocities[i]\r\n        errors.append((sim_vel - real_vel) ** 2)\r\n    return np.mean(errors)\r\n\r\n# Optimize\r\nresult = minimize(error_function, x0=0.1, bounds=[(0.01, 1.0)])\r\noptimal_friction = result.x[0]\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Step 3"}),": Update Isaac Sim"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"joint.set_joint_damping(optimal_friction)\n"})}),"\n",(0,a.jsx)(e.h3,{id:"automated-calibration",children:"Automated Calibration"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Loop"}),": Real robot \u2192 Sim \u2192 Compare \u2192 Adjust"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class SystemIDWorkflow:\r\n    def __init__(self, real_robot, sim_robot):\r\n        self.real = real_robot\r\n        self.sim = sim_robot\r\n\r\n    def run_experiment(self, commands):\r\n        # Run on real robot\r\n        real_data = self.real.execute(commands)\r\n        # Run in sim\r\n        sim_data = self.sim.execute(commands)\r\n        return real_data, sim_data\r\n\r\n    def calibrate(self, param_ranges, n_iterations=10):\r\n        best_params = None\r\n        best_error = float('inf')\r\n\r\n        for i in range(n_iterations):\r\n            # Sample parameters\r\n            params = {k: random.uniform(*v) for k, v in param_ranges.items()}\r\n            self.sim.set_parameters(params)\r\n\r\n            # Run experiments\r\n            real_data, sim_data = self.run_experiment(test_commands)\r\n\r\n            # Compute error\r\n            error = np.linalg.norm(real_data - sim_data)\r\n\r\n            if error < best_error:\r\n                best_error = error\r\n                best_params = params\r\n\r\n        return best_params\n"})}),"\n",(0,a.jsx)(e.h2,{id:"33-transfer-learning-strategies",children:"3.3 Transfer Learning Strategies"}),"\n",(0,a.jsx)(e.h3,{id:"pre-training-in-simulation",children:"Pre-training in Simulation"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Workflow"}),":"]}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsx)(e.li,{children:"Train policy in Isaac Sim (millions of samples)"}),"\n",(0,a.jsx)(e.li,{children:"Fine-tune on real robot (1000s of samples)"}),"\n",(0,a.jsx)(e.li,{children:"Deploy"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Example"})," (Grasping):"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'# 1. Train in simulation\r\npolicy = PPO("MlpPolicy", env=isaac_sim_env)\r\npolicy.learn(total_timesteps=1_000_000)\r\npolicy.save("policy_sim.zip")\r\n\r\n# 2. Fine-tune on real robot\r\npolicy = PPO.load("policy_sim.zip")\r\npolicy.set_env(real_robot_env)\r\npolicy.learn(total_timesteps=10_000)  # Fine-tune\r\npolicy.save("policy_real.zip")\n'})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Advantages"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Leverage sim for exploration"}),"\n",(0,a.jsx)(e.li,{children:"Real robot data only for final polish"}),"\n",(0,a.jsx)(e.li,{children:"Faster convergence (warm start from sim)"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"sim-to-real-adaptation",children:"Sim-to-Real Adaptation"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Progressive Networks"}),": Separate columns for sim and real"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ProgressivePolicy(nn.Module):\r\n    def __init__(self):\r\n        self.sim_column = nn.Sequential(...)  # Frozen after sim training\r\n        self.real_column = nn.Sequential(...)  # Trainable\r\n\r\n    def forward(self, state):\r\n        sim_features = self.sim_column(state)\r\n        real_features = self.real_column(state)\r\n        combined = torch.cat([sim_features, real_features], dim=-1)\r\n        return self.policy_head(combined)\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Domain Adversarial Training"}),": Learn domain-invariant features"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"# Discriminator predicts sim vs real\r\ndiscriminator = DomainClassifier(input_dim=128)\r\n\r\n# Policy learns to fool discriminator\r\npolicy_loss = task_loss - 0.1 * discriminator_loss\n"})}),"\n",(0,a.jsx)(e.h3,{id:"residual-learning",children:"Residual Learning"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Idea"}),": Policy = Sim policy + Residual (learned on real robot)"]}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ResidualPolicy:\r\n    def __init__(self, sim_policy_path):\r\n        self.sim_policy = load_policy(sim_policy_path)\r\n        self.sim_policy.freeze()  # Don't update\r\n\r\n        self.residual = nn.Sequential(\r\n            nn.Linear(obs_dim, 128),\r\n            nn.ReLU(),\r\n            nn.Linear(128, action_dim)\r\n        )\r\n\r\n    def get_action(self, obs):\r\n        sim_action = self.sim_policy(obs)\r\n        residual = self.residual(obs)\r\n        return sim_action + 0.1 * residual  # Small correction\n"})}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Train"}),": Only ",(0,a.jsx)(e.code,{children:"residual"})," on real robot, keep ",(0,a.jsx)(e.code,{children:"sim_policy"})," frozen"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Advantages"}),":"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Sim policy handles coarse behavior"}),"\n",(0,a.jsx)(e.li,{children:"Residual corrects for sim-to-real gap"}),"\n",(0,a.jsx)(e.li,{children:"Safer (residual bounded)"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Exercise 3.1"}),": Visual Domain Randomization for Object Detection"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Create an Isaac Sim scene with 10 household objects"}),"\n",(0,a.jsx)(e.li,{children:"Implement texture, lighting, and camera randomization with Replicator"}),"\n",(0,a.jsx)(e.li,{children:"Generate 5000 synthetic images with bounding box annotations"}),"\n",(0,a.jsx)(e.li,{children:"Train YOLOv8 on synthetic data and test on real images"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Exercise 3.2"}),": Physics Parameter Identification"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Set up a simple pendulum in both Isaac Sim and real hardware"}),"\n",(0,a.jsx)(e.li,{children:"Apply known torques and measure joint velocities on real system"}),"\n",(0,a.jsx)(e.li,{children:"Use optimization to fit simulation parameters (damping, friction)"}),"\n",(0,a.jsx)(e.li,{children:"Validate by comparing real and sim trajectories"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Exercise 3.3"}),": Curriculum-Based Domain Randomization"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Implement a curriculum randomizer for a robot grasping task"}),"\n",(0,a.jsx)(e.li,{children:"Start with minimal randomization (5% mass variation, high friction)"}),"\n",(0,a.jsx)(e.li,{children:"Progressively increase difficulty over training epochs"}),"\n",(0,a.jsx)(e.li,{children:"Plot success rate vs difficulty level"}),"\n"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Exercise 3.4"}),": Residual Policy Learning"]}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Train a base policy for robot navigation in Isaac Sim (1M steps)"}),"\n",(0,a.jsx)(e.li,{children:"Fine-tune with residual learning on real robot (10k steps)"}),"\n",(0,a.jsx)(e.li,{children:"Compare performance with: (a) sim-only, (b) real-only, (c) residual approach"}),"\n",(0,a.jsx)(e.li,{children:"Analyze which behaviors come from sim vs residual"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Domain Randomization"}),": Visual (textures, lighting), physics (mass, friction), curriculum learning\r\n",(0,a.jsx)(e.strong,{children:"System ID"}),": Parameter estimation from real data, automated calibration loops\r\n",(0,a.jsx)(e.strong,{children:"Transfer Learning"}),": Pre-training in sim, progressive networks, residual policies"]}),"\n",(0,a.jsxs)(e.p,{children:[(0,a.jsx)(e.strong,{children:"Next"}),": Chapter 4 covers control loops with RL and imitation learning in Isaac."]})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}}}]);