"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[7085],{28453:(n,e,i)=>{i.d(e,{R:()=>t,x:()=>c});var s=i(96540);const r={},l=s.createContext(r);function t(n){const e=s.useContext(l);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(r):n.components||r:t(n.components),s.createElement(l.Provider,{value:e},n.children)}},66818:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"chapters/module-2-digital-twin/gazebo-physics","title":"Chapter 2: Gazebo Physics","description":"Physics engines, contact modeling, and sensor simulation","source":"@site/docs/chapters/module-2-digital-twin/02-gazebo-physics.md","sourceDirName":"chapters/module-2-digital-twin","slug":"/chapters/module-2-digital-twin/gazebo-physics","permalink":"/Physical-AI-Humanoid-Robotics/chapters/module-2-digital-twin/gazebo-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/ayeshadev283-max/Physical-AI-Humanoid-Robotics/tree/main/docs/chapters/module-2-digital-twin/02-gazebo-physics.md","tags":[{"inline":true,"label":"gazebo","permalink":"/Physical-AI-Humanoid-Robotics/tags/gazebo"},{"inline":true,"label":"physics","permalink":"/Physical-AI-Humanoid-Robotics/tags/physics"},{"inline":true,"label":"ode","permalink":"/Physical-AI-Humanoid-Robotics/tags/ode"},{"inline":true,"label":"bullet","permalink":"/Physical-AI-Humanoid-Robotics/tags/bullet"},{"inline":true,"label":"dart","permalink":"/Physical-AI-Humanoid-Robotics/tags/dart"},{"inline":true,"label":"contact","permalink":"/Physical-AI-Humanoid-Robotics/tags/contact"},{"inline":true,"label":"sensors","permalink":"/Physical-AI-Humanoid-Robotics/tags/sensors"}],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"title":"Chapter 2: Gazebo Physics","description":"Physics engines, contact modeling, and sensor simulation","tags":["gazebo","physics","ode","bullet","dart","contact","sensors"]},"sidebar":"bookSidebar","previous":{"title":"Chapter 1: Digital Twin Basics","permalink":"/Physical-AI-Humanoid-Robotics/chapters/module-2-digital-twin/basics"},"next":{"title":"Chapter 3: Unity Animation","permalink":"/Physical-AI-Humanoid-Robotics/chapters/module-2-digital-twin/unity-animation"}}');var r=i(74848),l=i(28453);const t={sidebar_position:2,title:"Chapter 2: Gazebo Physics",description:"Physics engines, contact modeling, and sensor simulation",tags:["gazebo","physics","ode","bullet","dart","contact","sensors"]},c="Chapter 2: Gazebo Physics",o={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"2.1 Physics Engines",id:"21-physics-engines",level:2},{value:"Overview",id:"overview",level:3},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"DART",id:"dart",level:3},{value:"Comparison Table",id:"comparison-table",level:3},{value:"Selection Guidelines",id:"selection-guidelines",level:3},{value:"2.2 Contact Modeling",id:"22-contact-modeling",level:2},{value:"Contact Parameters",id:"contact-parameters",level:3},{value:"Friction Models",id:"friction-models",level:3},{value:"Restitution (Bounciness)",id:"restitution-bounciness",level:3},{value:"Contact Compliance",id:"contact-compliance",level:3},{value:"Contact Instabilities",id:"contact-instabilities",level:3},{value:"2.3 Sensor Simulation",id:"23-sensor-simulation",level:2},{value:"Camera",id:"camera",level:3},{value:"LiDAR (2D/3D)",id:"lidar-2d3d",level:3},{value:"IMU (Inertial Measurement Unit)",id:"imu-inertial-measurement-unit",level:3},{value:"Joint Encoders",id:"joint-encoders",level:3},{value:"Force/Torque Sensors",id:"forcetorque-sensors",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,l.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.header,{children:(0,r.jsx)(e.h1,{id:"chapter-2-gazebo-physics",children:"Chapter 2: Gazebo Physics"})}),"\n",(0,r.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"Compare physics engines (ODE, Bullet, DART) and select appropriate engine"}),"\n",(0,r.jsx)(e.li,{children:"Configure contact parameters (friction, compliance) for realistic simulation"}),"\n",(0,r.jsx)(e.li,{children:"Implement sensor plugins (camera, LiDAR, IMU) in Gazebo"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"21-physics-engines",children:"2.1 Physics Engines"}),"\n",(0,r.jsx)(e.h3,{id:"overview",children:"Overview"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Physics Engine"}),": Computes forces, collisions, and motion of rigid/soft bodies"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Gazebo"})," supports multiple engines via plugin architecture:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ODE"})," (Open Dynamics Engine): Default, stable, mature"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Bullet"}),": Fast, used in games and VR"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"DART"})," (Dynamic Animation and Robotics Toolkit): Accurate contact, best for manipulation"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Simbody"}),": Biomechanics-focused (rarely used in robotics)"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Strengths"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mature (20+ years of development)"}),"\n",(0,r.jsx)(e.li,{children:"Stable for wheeled robots and simple manipulation"}),"\n",(0,r.jsx)(e.li,{children:"Good documentation"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Weaknesses"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Less accurate contact resolution"}),"\n",(0,r.jsx)(e.li,{children:"Struggles with stacked objects (instability)"}),"\n",(0,r.jsx)(e.li,{children:"Slower convergence for complex contacts"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Cases"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mobile robots (differential drive, Ackermann steering)"}),"\n",(0,r.jsx)(e.li,{children:"Prototyping (quick setup)"}),"\n",(0,r.jsx)(e.li,{children:"Educational simulations"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="ode">\r\n  <max_step_size>0.001</max_step_size>\r\n  <real_time_factor>1.0</real_time_factor>\r\n  <real_time_update_rate>1000</real_time_update_rate>\r\n  <ode>\r\n    <solver>\r\n      <type>quick</type>\r\n      <iters>50</iters>\r\n      <sor>1.3</sor>\r\n    </solver>\r\n    <constraints>\r\n      <cfm>0.0</cfm>\r\n      <erp>0.2</erp>\r\n      <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n      <contact_surface_layer>0.001</contact_surface_layer>\r\n    </constraints>\r\n  </ode>\r\n</physics>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"bullet",children:"Bullet"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Strengths"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fast (optimized for real-time games)"}),"\n",(0,r.jsx)(e.li,{children:"Good for soft body dynamics (deformable objects)"}),"\n",(0,r.jsx)(e.li,{children:"Multi-threaded (can utilize multiple CPU cores)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Weaknesses"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Less deterministic (minor numerical differences across runs)"}),"\n",(0,r.jsx)(e.li,{children:"Contact constraints less precise than DART"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Cases"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fast simulation for reinforcement learning"}),"\n",(0,r.jsx)(e.li,{children:"Soft robotics (pneumatic actuators, flexible grippers)"}),"\n",(0,r.jsx)(e.li,{children:"Large-scale environments (100+ objects)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="bullet">\r\n  <max_step_size>0.001</max_step_size>\r\n  <bullet>\r\n    <solver>\r\n      <type>sequential_impulse</type>\r\n      <iters>50</iters>\r\n      <sor>1.3</sor>\r\n    </solver>\r\n    <constraints>\r\n      <cfm>0.0</cfm>\r\n      <erp>0.2</erp>\r\n      <split_impulse>true</split_impulse>\r\n    </constraints>\r\n  </bullet>\r\n</physics>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"dart",children:"DART"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Strengths"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Most accurate contact resolution (LCP solver)"}),"\n",(0,r.jsx)(e.li,{children:"Best for manipulation (grasping, assembly, contact-rich)"}),"\n",(0,r.jsx)(e.li,{children:"Deterministic (exact same results on repeated runs)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Weaknesses"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Slower (prioritizes accuracy over speed)"}),"\n",(0,r.jsx)(e.li,{children:"More complex configuration"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Cases"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Manipulation tasks (pick-and-place, in-hand manipulation)"}),"\n",(0,r.jsx)(e.li,{children:"Legged locomotion (foot contacts critical)"}),"\n",(0,r.jsx)(e.li,{children:"Sim-to-real transfer (minimizes reality gap)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<physics type="dart">\r\n  <max_step_size>0.001</max_step_size>\r\n  <dart>\r\n    <solver>\r\n      <solver_type>dantzig</solver_type>\r\n    </solver>\r\n    <collision_detector>bullet</collision_detector>\r\n  </dart>\r\n</physics>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"comparison-table",children:"Comparison Table"}),"\n",(0,r.jsxs)(e.table,{children:[(0,r.jsx)(e.thead,{children:(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.th,{children:"Feature"}),(0,r.jsx)(e.th,{children:"ODE"}),(0,r.jsx)(e.th,{children:"Bullet"}),(0,r.jsx)(e.th,{children:"DART"})]})}),(0,r.jsxs)(e.tbody,{children:[(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Speed"})}),(0,r.jsx)(e.td,{children:"Medium"}),(0,r.jsx)(e.td,{children:"Fast"}),(0,r.jsx)(e.td,{children:"Slow"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Contact Accuracy"})}),(0,r.jsx)(e.td,{children:"Low"}),(0,r.jsx)(e.td,{children:"Medium"}),(0,r.jsx)(e.td,{children:"High"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Stacking Stability"})}),(0,r.jsx)(e.td,{children:"Poor"}),(0,r.jsx)(e.td,{children:"Medium"}),(0,r.jsx)(e.td,{children:"Excellent"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Soft Bodies"})}),(0,r.jsx)(e.td,{children:"No"}),(0,r.jsx)(e.td,{children:"Yes"}),(0,r.jsx)(e.td,{children:"Limited"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Determinism"})}),(0,r.jsx)(e.td,{children:"Medium"}),(0,r.jsx)(e.td,{children:"Low"}),(0,r.jsx)(e.td,{children:"High"})]}),(0,r.jsxs)(e.tr,{children:[(0,r.jsx)(e.td,{children:(0,r.jsx)(e.strong,{children:"Best For"})}),(0,r.jsx)(e.td,{children:"Mobile robots"}),(0,r.jsx)(e.td,{children:"Fast RL"}),(0,r.jsx)(e.td,{children:"Manipulation"})]})]})]}),"\n",(0,r.jsx)(e.h3,{id:"selection-guidelines",children:"Selection Guidelines"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Choose ODE"})," if:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Mobile robot (no complex contacts)"}),"\n",(0,r.jsx)(e.li,{children:"Need quick setup with defaults"}),"\n",(0,r.jsx)(e.li,{children:"Educational use"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Choose Bullet"})," if:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Need ",(0,r.jsx)(e.code,{children:">1x"})," real-time speed"]}),"\n",(0,r.jsx)(e.li,{children:"Soft body simulation"}),"\n",(0,r.jsx)(e.li,{children:"Determinism not critical"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Choose DART"})," if:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Manipulation or legged robots"}),"\n",(0,r.jsx)(e.li,{children:"Accuracy more important than speed"}),"\n",(0,r.jsx)(e.li,{children:"Sim-to-real transfer planned"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"22-contact-modeling",children:"2.2 Contact Modeling"}),"\n",(0,r.jsx)(e.h3,{id:"contact-parameters",children:"Contact Parameters"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Contact"})," occurs when two collision geometries overlap"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Key Parameters"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Friction"})," (\u03bc): Resistance to sliding"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Restitution"})," (e): Bounciness (0 = inelastic, 1 = perfectly elastic)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Contact stiffness"}),' (k): How "hard" the surface feels']}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Contact damping"})," (c): Energy dissipation during contact"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"friction-models",children:"Friction Models"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Coulomb Friction"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.code,{children:"F_friction \u2264 \u03bc * F_normal"})}),"\n",(0,r.jsx)(e.li,{children:"Static friction (\u03bc_s) > dynamic friction (\u03bc_d)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"In Gazebo"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<surface>\r\n  <friction>\r\n    <ode>\r\n      <mu>0.8</mu>    \x3c!-- Coefficient of friction --\x3e\r\n      <mu2>0.8</mu2>  \x3c!-- Secondary direction (anisotropic) --\x3e\r\n      <fdir1>1 0 0</fdir1>  \x3c!-- Primary friction direction --\x3e\r\n      <slip1>0.0</slip1>\r\n      <slip2>0.0</slip2>\r\n    </ode>\r\n  </friction>\r\n</surface>\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Material-Specific Values"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Rubber on concrete: \u03bc = 0.9-1.0"}),"\n",(0,r.jsx)(e.li,{children:"Metal on metal: \u03bc = 0.15-0.3"}),"\n",(0,r.jsx)(e.li,{children:"Ice on ice: \u03bc = 0.02-0.05"}),"\n",(0,r.jsx)(e.li,{children:"Gripper pad on plastic: \u03bc = 0.6-0.8"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Anisotropic Friction"})," (direction-dependent):"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Example: Tank tracks (high lateral friction, low longitudinal)"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"restitution-bounciness",children:"Restitution (Bounciness)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Coefficient of Restitution"})," (e):"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"0: Perfectly inelastic (object sticks)"}),"\n",(0,r.jsx)(e.li,{children:"0.5: Loses half its velocity"}),"\n",(0,r.jsx)(e.li,{children:"1: Perfectly elastic (bounces back to same height)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"In Gazebo"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<surface>\r\n  <bounce>\r\n    <restitution_coefficient>0.2</restitution_coefficient>\r\n    <threshold>0.01</threshold>  \x3c!-- Min velocity for bounce --\x3e\r\n  </bounce>\r\n</surface>\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Cases"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Ball: e = 0.7-0.9"}),"\n",(0,r.jsx)(e.li,{children:"Cube on table: e = 0.1-0.3"}),"\n",(0,r.jsx)(e.li,{children:"Soft gripper: e = 0.0-0.1"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"contact-compliance",children:"Contact Compliance"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Hard Contact"})," (default):"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Instantaneous collision resolution"}),"\n",(0,r.jsx)(e.li,{children:"No penetration allowed"}),"\n",(0,r.jsx)(e.li,{children:"Can cause instability (jitter, explosions)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Soft Contact"})," (compliant):"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Allow small penetration (spring-damper model)"}),"\n",(0,r.jsx)(e.li,{children:"More stable, especially for stacking"}),"\n",(0,r.jsx)(e.li,{children:'Adds compliance (objects "squish")'}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Configuration"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:"<surface>\r\n  <contact>\r\n    <ode>\r\n      <kp>1e6</kp>     \x3c!-- Contact stiffness (N/m) --\x3e\r\n      <kd>100.0</kd>   \x3c!-- Contact damping (N\xb7s/m) --\x3e\r\n      <max_vel>0.01</max_vel>  \x3c!-- Max penetration velocity --\x3e\r\n      <min_depth>0.001</min_depth>  \x3c!-- Allowed penetration --\x3e\r\n    </ode>\r\n  </contact>\r\n</surface>\n"})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Tuning"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["High ",(0,r.jsx)(e.code,{children:"kp"})," (stiff): Realistic but can jitter"]}),"\n",(0,r.jsxs)(e.li,{children:["Low ",(0,r.jsx)(e.code,{children:"kp"})," (soft): Stable but objects sink"]}),"\n",(0,r.jsxs)(e.li,{children:["Rule of thumb: ",(0,r.jsx)(e.code,{children:"kp = object_mass / desired_penetration"})]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"contact-instabilities",children:"Contact Instabilities"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Problem"}),": Stacked objects vibrate or explode"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Causes"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Timestep too large (",(0,r.jsx)(e.code,{children:"max_step_size > 0.001"}),")"]}),"\n",(0,r.jsxs)(e.li,{children:["Insufficient solver iterations (",(0,r.jsx)(e.code,{children:"iters < 50"}),")"]}),"\n",(0,r.jsx)(e.li,{children:"Conflicting contacts (box corners on uneven ground)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Solutions"}),":"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["Reduce timestep: ",(0,r.jsx)(e.code,{children:"max_step_size = 0.0005"})," (slower)"]}),"\n",(0,r.jsxs)(e.li,{children:["Increase iterations: ",(0,r.jsx)(e.code,{children:"iters = 100"})," (more accurate)"]}),"\n",(0,r.jsxs)(e.li,{children:["Increase damping: ",(0,r.jsx)(e.code,{children:"kd = 200"})," (more energy loss)"]}),"\n",(0,r.jsx)(e.li,{children:"Use DART engine (better contact solver)"}),"\n",(0,r.jsx)(e.li,{children:"Simplify geometry (rounded corners instead of sharp edges)"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"23-sensor-simulation",children:"2.3 Sensor Simulation"}),"\n",(0,r.jsx)(e.h3,{id:"camera",children:"Camera"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Types"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Monocular"}),": Single RGB camera"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Stereo"}),": Two cameras for depth"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Depth"}),": RGB-D (Kinect-style)"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Plugin"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="camera" type="camera">\r\n  <update_rate>30</update_rate>\r\n  <camera>\r\n    <horizontal_fov>1.047</horizontal_fov>  \x3c!-- 60 degrees --\x3e\r\n    <image>\r\n      <width>640</width>\r\n      <height>480</height>\r\n      <format>R8G8B8</format>\r\n    </image>\r\n    <clip>\r\n      <near>0.1</near>\r\n      <far>100</far>\r\n    </clip>\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.007</stddev>  \x3c!-- Per-channel noise --\x3e\r\n    </noise>\r\n  </camera>\r\n  <plugin name="camera_controller" filename="libgazebo_ros_camera.so">\r\n    <ros>\r\n      <remapping>image_raw:=camera/image</remapping>\r\n    </ros>\r\n  </plugin>\r\n</sensor>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Realism Enhancements"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Lens distortion: Radial/tangential coefficients"}),"\n",(0,r.jsx)(e.li,{children:"Motion blur: Simulate fast camera motion"}),"\n",(0,r.jsx)(e.li,{children:"Rolling shutter: Row-by-row exposure (CMOS sensors)"}),"\n",(0,r.jsx)(e.li,{children:"Auto-exposure: Dynamic brightness adjustment"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"lidar-2d3d",children:"LiDAR (2D/3D)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"2D LiDAR"})," (e.g., SICK, Hokuyo):"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="lidar" type="gpu_ray">\r\n  <update_rate>10</update_rate>\r\n  <ray>\r\n    <scan>\r\n      <horizontal>\r\n        <samples>720</samples>\r\n        <resolution>1</resolution>\r\n        <min_angle>-3.14159</min_angle>\r\n        <max_angle>3.14159</max_angle>\r\n      </horizontal>\r\n    </scan>\r\n    <range>\r\n      <min>0.1</min>\r\n      <max>30.0</max>\r\n      <resolution>0.01</resolution>\r\n    </range>\r\n    <noise>\r\n      <type>gaussian</type>\r\n      <mean>0.0</mean>\r\n      <stddev>0.01</stddev>\r\n    </noise>\r\n  </ray>\r\n  <plugin name="lidar_controller" filename="libgazebo_ros_ray_sensor.so">\r\n    <ros>\r\n      <remapping>~/out:=scan</remapping>\r\n    </ros>\r\n  </plugin>\r\n</sensor>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"3D LiDAR"})," (Velodyne, Ouster):"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Add ",(0,r.jsx)(e.code,{children:"<vertical>"})," scan parameters"]}),"\n",(0,r.jsx)(e.li,{children:"Higher computational cost (100k+ points/sec)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"GPU Acceleration"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:'type="gpu_ray"'})," uses GPU ray-tracing"]}),"\n",(0,r.jsx)(e.li,{children:"10-100x faster than CPU version"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"imu-inertial-measurement-unit",children:"IMU (Inertial Measurement Unit)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Measures"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Linear acceleration (m/s\xb2)"}),"\n",(0,r.jsx)(e.li,{children:"Angular velocity (rad/s)"}),"\n",(0,r.jsx)(e.li,{children:"(Optional) Orientation (from magnetometer)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Plugin"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="imu" type="imu">\r\n  <update_rate>100</update_rate>\r\n  <imu>\r\n    <angular_velocity>\r\n      <x>\r\n        <noise type="gaussian">\r\n          <mean>0</mean>\r\n          <stddev>0.009</stddev>  \x3c!-- Gyro noise (rad/s) --\x3e\r\n          <bias_mean>0.00075</bias_mean>\r\n          <bias_stddev>0.0000008</bias_stddev>\r\n        </noise>\r\n      </x>\r\n      \x3c!-- Repeat for y, z --\x3e\r\n    </angular_velocity>\r\n    <linear_acceleration>\r\n      <x>\r\n        <noise type="gaussian">\r\n          <mean>0</mean>\r\n          <stddev>0.017</stddev>  \x3c!-- Accel noise (m/s\xb2) --\x3e\r\n          <bias_mean>0.1</bias_mean>\r\n          <bias_stddev>0.001</bias_stddev>\r\n        </noise>\r\n      </x>\r\n      \x3c!-- Repeat for y, z --\x3e\r\n    </linear_acceleration>\r\n  </imu>\r\n  <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">\r\n    <ros>\r\n      <remapping>~/out:=imu/data</remapping>\r\n    </ros>\r\n  </plugin>\r\n</sensor>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Noise Modeling"}),":"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"White noise"}),": Random fluctuations"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Bias"}),": Constant offset (drifts over time)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Bias instability"}),": Slow bias changes"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Calibration"}),": Measure real IMU noise, configure sim to match"]}),"\n",(0,r.jsx)(e.h3,{id:"joint-encoders",children:"Joint Encoders"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Measures"}),": Joint positions and velocities"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Plugin"})," (via ",(0,r.jsx)(e.code,{children:"libgazebo_ros2_control"}),"):"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["Automatically publishes ",(0,r.jsx)(e.code,{children:"sensor_msgs/JointState"})]}),"\n",(0,r.jsx)(e.li,{children:"No explicit sensor tag needed (part of robot URDF)"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Noise"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<joint name="elbow_joint">\r\n  <dynamics damping="0.1"/>\r\n  <sensor_noise>0.001</sensor_noise>  \x3c!-- Position noise (rad) --\x3e\r\n</joint>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"forcetorque-sensors",children:"Force/Torque Sensors"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Measures"}),": Forces and torques at joints (e.g., wrist force sensor)"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Plugin"}),":"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<sensor name="force_torque" type="force_torque">\r\n  <update_rate>100</update_rate>\r\n  <force_torque>\r\n    <frame>child</frame>  \x3c!-- Measure in child link frame --\x3e\r\n    <measure_direction>child_to_parent</measure_direction>\r\n  </force_torque>\r\n  <plugin name="ft_plugin" filename="libgazebo_ros_ft_sensor.so"/>\r\n</sensor>\n'})}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Use Cases"}),": Compliant control, grasp force regulation"]}),"\n",(0,r.jsx)(e.mermaid,{value:'graph TB\r\n    subgraph Gazebo["Gazebo Simulation"]\r\n        World[World<br/>SDF File]\r\n        Physics[Physics Engine<br/>ODE/Bullet/DART]\r\n        Rendering[Rendering Engine<br/>Ogre2]\r\n    end\r\n\r\n    subgraph Plugins["Gazebo Plugins"]\r\n        ModelPlugin[Model Plugin<br/>Control robots]\r\n        SensorPlugin[Sensor Plugin<br/>Camera, LiDAR]\r\n        WorldPlugin[World Plugin<br/>Environment logic]\r\n        SystemPlugin[System Plugin<br/>ROS 2 bridge]\r\n    end\r\n\r\n    subgraph ROS2["ROS 2"]\r\n        Topics[Topics<br/>/cmd_vel, /scan]\r\n        Services[Services<br/>/spawn_entity]\r\n        Actions[Actions<br/>/navigate]\r\n    end\r\n\r\n    World --\x3e Physics\r\n    Physics --\x3e Rendering\r\n    \r\n    World --\x3e ModelPlugin\r\n    World --\x3e SensorPlugin\r\n    World --\x3e WorldPlugin\r\n    World --\x3e SystemPlugin\r\n\r\n    ModelPlugin --\x3e|Publish| Topics\r\n    SensorPlugin --\x3e|Publish| Topics\r\n    Topics --\x3e|Subscribe| ModelPlugin\r\n    Services <--\x3e SystemPlugin\r\n    Actions <--\x3e SystemPlugin\r\n\r\n    style Gazebo fill:#cce1ff\r\n    style Plugins fill:#ffffcc\r\n    style ROS2 fill:#ccffcc'}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Figure 2.1"}),": Gazebo plugin architecture. Plugins attach to world, models, or sensors and interface with ROS 2 for bidirectional communication. The physics engine computes dynamics, while plugins handle I/O and control logic."]}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Physics Engines"}),": ODE (stable), Bullet (fast), DART (accurate manipulation)\r\n",(0,r.jsx)(e.strong,{children:"Contact"}),": Friction (\u03bc), restitution (e), compliance (kp, kd) for realistic interactions\r\n",(0,r.jsx)(e.strong,{children:"Sensors"}),": Camera, LiDAR, IMU, joint encoders with noise models for sim-to-real"]}),"\n",(0,r.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Exercise 2.1"}),": Compare ODE, Bullet, and DART for a robot arm picking a fragile object. Run the same scenario in all three engines and measure:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Task success rate"}),"\n",(0,r.jsx)(e.li,{children:"Contact forces (should be gentle)"}),"\n",(0,r.jsx)(e.li,{children:"Simulation speed (real-time factor)\r\nWhich engine is best? Why?"}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Exercise 2.2"}),": Tune contact parameters for realistic box stacking. Start with default Gazebo settings (often unstable). Adjust kp (stiffness), kd (damping), friction (\u03bc), and solver iterations until a 5-box stack is stable for 10 seconds. Document your final parameters."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Exercise 2.3"}),": Add sensor noise to a camera plugin to match real sensor specifications. If your camera has 0.007 stddev per-channel noise (from datasheet), configure Gazebo to match. Capture images, measure noise, and verify it matches."]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Exercise 2.4"}),": Create a custom Gazebo plugin that publishes joint torques to ROS 2. The plugin should:"]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Read torques from ArticulationBody or physics engine"}),"\n",(0,r.jsxs)(e.li,{children:["Publish to ",(0,r.jsx)(e.code,{children:"/joint_torques"})," topic"]}),"\n",(0,r.jsx)(e.li,{children:"Update at 100 Hz\r\nTest by commanding the robot and observing torque changes."}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.strong,{children:"Next"}),": Chapter 3 covers Unity for high-fidelity rendering and animation."]})]})}function h(n={}){const{wrapper:e}={...(0,l.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}}}]);